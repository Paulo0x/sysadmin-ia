# Validation code Terraform avec assistance IA

## Objectif

Auditer et valider du code Infrastructure as Code (Terraform) pour détecter erreurs de syntaxe, problèmes de sécurité, non-respect des best practices et optimisations possibles en exploitant l'IA pour une analyse rapide et complète.

## Contexte entreprise

Une équipe DevOps de 5 personnes gère une infrastructure AWS via Terraform :
- 15 modules Terraform (VPC, EC2, RDS, S3, IAM)
- 3 environnements (dev, staging, prod)
- Code accumulé sur 2 ans par différents ingénieurs
- Pas de revue de code systématique

**Problèmes rencontrés** :
- Erreurs de syntaxe découvertes au `terraform apply`
- Ressources créées non conformes aux standards sécurité
- Code dupliqué entre modules
- Performances dégradées (plans trop longs)
- Drift entre code et infrastructure réelle

**Objectif** : Auditer et corriger les 15 modules en 3 jours au lieu de 10 jours.

## Problème

Valider du code Terraform manuellement implique :
- Lire des milliers de lignes de .tf
- Connaître les best practices AWS + Terraform
- Identifier les failles de sécurité (buckets S3 publics, ports ouverts)
- Détecter le code dupliqué
- Vérifier la cohérence entre modules

**Temps estimé** : 4-6 heures par module = 60-90 heures pour 15 modules

**Difficultés** :
- Syntaxe HCL parfois complexe
- Multiples versions de providers AWS
- Standards de sécurité AWS en évolution
- Détection manuelle fastidieuse

## Solution traditionnelle

### Méthode manuelle

```bash
# Validation basique
terraform fmt
terraform validate

# Déploiement test
terraform plan

# Revue de code manuelle
# Relecture ligne par ligne des .tf
# Vérification sécurité manuelle
```

**Problèmes** :
- `terraform validate` ne détecte que syntaxe, pas sécurité
- Revue manuelle chronophage
- Risque d'oubli de problèmes critiques
- Pas d'analyse inter-modules

## Apport de l'IA

L'IA permet de :
- Analyser instantanément des modules Terraform complexes
- Détecter les failles de sécurité (CIS AWS benchmark)
- Identifier code dupliqué et proposer refactoring
- Suggérer optimisations de performance
- Générer corrections conformes aux best practices
- Expliquer les problèmes détectés

**Temps avec IA** : 30-60 minutes par module

**Gain de productivité** : 85-90%

## Mise en œuvre étape par étape

### Étape 1 : Audit basique avec outils automatisés

**Action** : Utiliser terraform-docs, tflint, tfsec avant analyse IA

```bash
# Installation outils
brew install terraform-docs tflint tfsec

# Validation syntaxe
terraform fmt -check -recursive
terraform validate

# Linting
tflint --init
tflint --recursive

# Analyse sécurité
tfsec . --format=json > tfsec-report.json
```

**Résultat** : Rapport initial des problèmes détectés automatiquement

### Étape 2 : Analyse approfondie avec l'IA

**Prompt** :

```
Analyse ce module Terraform AWS EC2.

Code :
[Copier le fichier main.tf complet]

Identifie :
1. Problèmes de sécurité (ports ouverts, IMDSv1, IAM trop permissif)
2. Non-respect des best practices Terraform
3. Code non optimal ou dupliqué
4. Ressources manquantes (tags, monitoring, backup)
5. Suggestions d'amélioration

Format : Liste structurée par criticité (CRITIQUE/MOYEN/FAIBLE)
```

**Exemple de code analysé** :

```hcl
# main.tf
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  vpc_security_group_ids = [aws_security_group.web_sg.id]

  user_data = <<-EOF
    #!/bin/bash
    apt-get update
    apt-get install -y nginx
  EOF
}

resource "aws_security_group" "web_sg" {
  name = "web-sg"

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```

**Réponse IA** :

```
=== AUDIT MODULE TERRAFORM EC2 ===

[CRITIQUE] Sécurité
1. SSH exposé publiquement (0.0.0.0/0)
   → Risque : Brute force attacks, compromission instance
   → Correction : Limiter accès SSH à IP admin ou bastion
   → Code : cidr_blocks = ["203.0.113.10/32"]

2. IMDSv1 activé par défaut
   → Risque : SSRF attacks, vol credentials IAM
   → Correction : Forcer IMDSv2
   → Code :
     metadata_options {
       http_endpoint = "enabled"
       http_tokens   = "required"  # IMDSv2
     }

3. Instance sans IAM role
   → Risque : Credentials hardcodées dans user_data
   → Correction : Créer IAM instance profile

4. User data en clair dans Terraform
   → Risque : Exposition de scripts dans state
   → Correction : Externaliser dans fichier séparé

[MOYEN] Best Practices
5. AMI hardcodée
   → Problème : Pas de gestion multi-région, AMI obsolète
   → Correction : Utiliser data source pour AMI la plus récente

6. Pas de tags sur les ressources
   → Problème : Difficulté à tracker coûts et ownership
   → Correction : Ajouter tags (Environment, Owner, Project)

7. Security group sans description
   → Problème : Règles non documentées
   → Correction : Ajouter description à chaque règle

8. Pas de monitoring
   → Problème : Aucune alerte en cas de panne
   → Correction : Activer CloudWatch detailed monitoring

[FAIBLE] Optimisation
9. Instance type hardcodé
   → Amélioration : Utiliser variable pour flexibilité

10. Pas de lifecycle rules
    → Amélioration : Ajouter prevent_destroy pour protection prod

11. Security group nommage non standardisé
    → Amélioration : Utiliser naming convention claire
```

### Étape 3 : Génération du code corrigé

**Prompt** :

```
Génère le code Terraform corrigé avec tous les problèmes CRITIQUES et MOYENS résolus.

Problèmes identifiés :
[Copier la liste des problèmes]

Format : Fichiers Terraform complets (main.tf, variables.tf, outputs.tf)
```

**Réponse IA** :

```hcl
# variables.tf
variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

variable "admin_cidr" {
  description = "CIDR allowed for SSH access"
  type        = string
  default     = "203.0.113.10/32"  # IP admin
}

variable "common_tags" {
  description = "Common tags for all resources"
  type        = map(string)
}

# main.tf
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]  # Canonical

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

resource "aws_iam_role" "web_role" {
  name = "${var.environment}-web-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "ec2.amazonaws.com"
      }
    }]
  })

  tags = var.common_tags
}

resource "aws_iam_instance_profile" "web_profile" {
  name = "${var.environment}-web-profile"
  role = aws_iam_role.web_role.name

  tags = var.common_tags
}

resource "aws_security_group" "web_sg" {
  name        = "${var.environment}-web-sg"
  description = "Security group for web servers"

  ingress {
    description = "SSH from admin IP only"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = [var.admin_cidr]
  }

  ingress {
    description = "HTTP from Internet"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    description = "HTTPS from Internet"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    description = "Allow all outbound"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = merge(
    var.common_tags,
    {
      Name = "${var.environment}-web-sg"
    }
  )
}

resource "aws_instance" "web" {
  ami                    = data.aws_ami.ubuntu.id
  instance_type          = var.instance_type
  iam_instance_profile   = aws_iam_instance_profile.web_profile.name
  vpc_security_group_ids = [aws_security_group.web_sg.id]

  # Force IMDSv2
  metadata_options {
    http_endpoint = "enabled"
    http_tokens   = "required"
    http_put_response_hop_limit = 1
  }

  # Enable detailed monitoring
  monitoring = true

  # EBS optimization
  ebs_optimized = true

  # User data externalisé
  user_data = file("${path.module}/user_data.sh")

  # Root volume encryption
  root_block_device {
    encrypted = true
    volume_size = 20
    volume_type = "gp3"
  }

  # Lifecycle
  lifecycle {
    create_before_destroy = true
    ignore_changes        = [ami]  # Ignore AMI changes to prevent recreation
  }

  tags = merge(
    var.common_tags,
    {
      Name = "${var.environment}-web-server"
    }
  )
}

# outputs.tf
output "instance_id" {
  description = "ID of the EC2 instance"
  value       = aws_instance.web.id
}

output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.web.public_ip
}

output "security_group_id" {
  description = "ID of the security group"
  value       = aws_security_group.web_sg.id
}
```

**Fichier user_data.sh** :

```bash
#!/bin/bash
set -euo pipefail

# Logging
exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1

echo "Starting user data script"

# Update system
apt-get update -y
apt-get upgrade -y

# Install nginx
apt-get install -y nginx

# Enable nginx
systemctl enable nginx
systemctl start nginx

echo "User data script completed"
```

### Étape 4 : Validation des modules inter-dépendants

**Prompt** :

```
Analyse la cohérence entre ces 3 modules Terraform.

Module VPC (networking) :
[Code vpc/main.tf]

Module EC2 (compute) :
[Code ec2/main.tf]

Module RDS (database) :
[Code rds/main.tf]

Identifie :
1. Références circulaires
2. Outputs manquants nécessaires à d'autres modules
3. Duplication de code entre modules
4. Incohérences de configuration (ex: subnet différent)

Format : Tableau comparatif + recommandations
```

**Réponse IA** :

```
=== ANALYSE INTER-MODULES ===

PROBLÈMES DÉTECTÉS :

1. [CRITIQUE] Module EC2 référence security_group_id hardcodé
   Module EC2 (ligne 45) :
   vpc_security_group_ids = ["sg-0123456789abcdef"]

   → Problème : Référence hardcodée, ne fonctionnera pas dans autre environnement
   → Correction : Utiliser output du module VPC
   vpc_security_group_ids = [module.vpc.web_sg_id]

2. [CRITIQUE] Module RDS ne spécifie pas le subnet group
   Module RDS (ligne 12) :
   Pas de db_subnet_group_name défini

   → Problème : RDS sera créé dans subnet par défaut (public !)
   → Correction : Référencer subnet group du module VPC
   db_subnet_group_name = module.vpc.db_subnet_group_name

3. [MOYEN] Tags dupliqués dans chaque module
   Chaque module redéfinit :
   tags = {
     Environment = "prod"
     Owner       = "DevOps"
   }

   → Problème : Duplication, risque d'incohérence
   → Correction : Créer module "locals" partagé
   locals.tf (root) :
   locals {
     common_tags = {
       Environment = var.environment
       Owner       = "DevOps"
       ManagedBy   = "Terraform"
     }
   }

4. [MOYEN] Variables redondantes entre modules
   Variable "environment" définie dans VPC, EC2, RDS

   → Correction : Définir au niveau root, passer aux modules
   Root main.tf :
   module "vpc" {
     source      = "./modules/vpc"
     environment = var.environment
   }

5. [FAIBLE] Outputs manquants pour réutilisation
   Module VPC ne retourne pas :
   - private_subnet_ids (nécessaire pour RDS)
   - nat_gateway_id (utile pour monitoring)

   → Correction : Ajouter outputs dans vpc/outputs.tf

RECOMMANDATIONS :

1. Créer un module "common" pour tags et variables partagées
2. Utiliser remote state pour partager outputs entre modules
3. Documenter les dépendances entre modules (README)
4. Utiliser terraform graph pour visualiser dépendances
```

### Étape 5 : Optimisation des performances

**Prompt** :

```
Mon terraform plan prend 5 minutes. Optimise ce code Terraform.

Code :
[Copier le code]

Nombre de ressources : 120
Providers : aws, cloudflare, datadog

Identifie les goulots d'étranglement et propose optimisations.
```

**Réponse IA** :

```
=== OPTIMISATION PERFORMANCES TERRAFORM ===

CAUSES PROBABLES DE LENTEUR :

1. [MAJEURE] Trop d'appels API séquentiels
   Chaque data source AWS fait un appel API :
   data "aws_ami" "ubuntu" { ... }  # Appel 1
   data "aws_subnet" "private_a" { ... }  # Appel 2
   ...

   → Solution : Utiliser -parallelism
   terraform plan -parallelism=20

2. [MAJEURE] State remote lent
   Backend S3 sans DynamoDB lock :
   backend "s3" {
     bucket = "terraform-state"
   }

   → Solution : Ajouter DynamoDB pour locking rapide
   backend "s3" {
     bucket         = "terraform-state"
     dynamodb_table = "terraform-locks"
     encrypt        = true
   }

3. [MOYENNE] Pas de cache provider
   Providers re-téléchargés à chaque init

   → Solution : Utiliser plugin cache
   ~/.terraformrc :
   plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"

4. [MOYENNE] Data sources coûteuses dans boucles
   data "aws_instance" "this" {
     for_each = toset(var.instance_ids)  # 50 instances
     ...
   }

   → Solution : Utiliser filter au lieu de boucle
   data "aws_instances" "this" {
     filter {
       name   = "tag:Environment"
       values = ["prod"]
     }
   }

5. [FAIBLE] Logs trop verbeux
   TF_LOG=TRACE ralentit l'exécution

   → Solution : Utiliser TF_LOG=ERROR en prod

OPTIMISATIONS RECOMMANDÉES :

1. Séparer les modules peu modifiés (VPC) des fréquents (EC2)
2. Utiliser terraform refresh=false si state à jour
3. Activer parallel iterations (v1.5+)
4. Utiliser partial backend config pour multi-env

TEMPS ESTIMÉ APRÈS OPTIMISATION : <1 minute
```

### Étape 6 : Génération de tests automatisés

**Prompt** :

```
Génère des tests Terraform (Terratest) pour ce module EC2.

Module :
[Code du module EC2 corrigé]

Tests requis :
1. Instance créée avec bon type
2. Security group a règle SSH limitée (pas 0.0.0.0/0)
3. IMDSv2 activé
4. Tags présents

Format : Code Go (Terratest)
```

**Réponse IA** :

```go
// ec2_test.go
package test

import (
	"testing"

	"github.com/gruntwork-io/terratest/modules/terraform"
	"github.com/stretchr/testify/assert"
)

func TestEC2Module(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../modules/ec2",
		Vars: map[string]interface{}{
			"environment": "test",
			"instance_type": "t3.micro",
			"admin_cidr": "203.0.113.10/32",
			"common_tags": map[string]string{
				"Environment": "test",
				"Owner":       "terratest",
			},
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	// Test 1: Instance créée avec bon type
	instanceType := terraform.Output(t, terraformOptions, "instance_type")
	assert.Equal(t, "t3.micro", instanceType)

	// Test 2: Security Group SSH limité
	sgRules := terraform.OutputList(t, terraformOptions, "sg_ingress_rules")
	sshRule := findSSHRule(sgRules)
	assert.NotEqual(t, "0.0.0.0/0", sshRule.CidrBlocks[0], "SSH should not be open to 0.0.0.0/0")

	// Test 3: IMDSv2 activé
	metadataOptions := terraform.OutputMap(t, terraformOptions, "metadata_options")
	assert.Equal(t, "required", metadataOptions["http_tokens"], "IMDSv2 should be enforced")

	// Test 4: Tags présents
	tags := terraform.OutputMap(t, terraformOptions, "tags")
	assert.Equal(t, "test", tags["Environment"])
	assert.Contains(t, tags, "Owner")
}

func findSSHRule(rules []interface{}) map[string]interface{} {
	for _, rule := range rules {
		r := rule.(map[string]interface{})
		if r["from_port"] == 22 {
			return r
		}
	}
	return nil
}
```

## Scripts / Commandes / Configurations

### Script d'audit complet

```bash
#!/bin/bash
# terraform-audit.sh
# Audit complet d'un projet Terraform

set -euo pipefail

PROJECT_DIR=${1:-.}
REPORT_DIR="./audit-reports"
DATE=$(date +%Y%m%d-%H%M)

mkdir -p "$REPORT_DIR"

echo "=== Audit Terraform : $PROJECT_DIR ==="

# 1. Validation syntaxe
echo "[1/5] Validation syntaxe..."
terraform -chdir="$PROJECT_DIR" fmt -check -recursive > "$REPORT_DIR/fmt-$DATE.log" 2>&1 || true
terraform -chdir="$PROJECT_DIR" validate > "$REPORT_DIR/validate-$DATE.log" 2>&1 || true

# 2. Linting
echo "[2/5] Linting (tflint)..."
tflint --chdir="$PROJECT_DIR" --format=json > "$REPORT_DIR/tflint-$DATE.json" 2>&1 || true

# 3. Sécurité
echo "[3/5] Analyse sécurité (tfsec)..."
tfsec "$PROJECT_DIR" --format=json --out="$REPORT_DIR/tfsec-$DATE.json" || true

# 4. Coût estimation (si infracost installé)
if command -v infracost &> /dev/null; then
    echo "[4/5] Estimation coûts..."
    infracost breakdown --path="$PROJECT_DIR" --format=json --out-file="$REPORT_DIR/infracost-$DATE.json" || true
fi

# 5. Documentation
echo "[5/5] Génération documentation..."
terraform-docs markdown table "$PROJECT_DIR" > "$REPORT_DIR/docs-$DATE.md"

echo ""
echo "=== Résumé ===" echo "Rapports générés dans : $REPORT_DIR"
ls -lh "$REPORT_DIR"/*-$DATE.*

# Compter les problèmes
CRITICAL=$(jq -r '[.results[].rule_severity] | map(select(. == "CRITICAL")) | length' "$REPORT_DIR/tfsec-$DATE.json" 2>/dev/null || echo "0")
echo ""
echo "Problèmes CRITIQUES détectés : $CRITICAL"

if [ "$CRITICAL" -gt 0 ]; then
    echo "⚠️  Action requise : corriger les problèmes critiques"
    exit 1
else
    echo "✓ Aucun problème critique"
fi
```

### Pre-commit hook Terraform

```bash
#!/bin/bash
# .git/hooks/pre-commit
# Hook pré-commit pour valider Terraform

set -e

echo "Running Terraform pre-commit checks..."

# Format
terraform fmt -check -recursive || {
    echo "Error: Terraform files not formatted. Run 'terraform fmt -recursive'"
    exit 1
}

# Validate
terraform validate || {
    echo "Error: Terraform validation failed"
    exit 1
}

# tfsec (seulement erreurs critiques bloquent)
tfsec . --minimum-severity CRITICAL --soft-fail || {
    echo "Error: Critical security issues found"
    exit 1
}

echo "✓ Pre-commit checks passed"
```

### Makefile pour commandes courantes

```makefile
# Makefile
.PHONY: init plan apply destroy validate audit

init:
	terraform init -upgrade

validate:
	terraform fmt -check -recursive
	terraform validate
	tflint --recursive
	tfsec .

plan:
	terraform plan -out=tfplan

apply:
	terraform apply tfplan

destroy:
	terraform destroy

audit:
	./scripts/terraform-audit.sh

docs:
	terraform-docs markdown table . > README.md

clean:
	rm -rf .terraform tfplan .terraform.lock.hcl
```

## Risques et limites

### Risques d'automatisation

**Confiance aveugle** : L'IA peut manquer des problèmes contextuels. Toujours relire le code généré.

**Breaking changes** : Refactoring suggéré par IA peut casser l'infra existante. Tester en dev d'abord.

**State corruption** : Modifications manuelles du state peuvent causer des incohérences. Toujours versionner le state.

### Limites de l'IA

**Providers custom** : L'IA connaît mal les providers tiers récents. Vérifier documentation.

**Versions Terraform** : Syntaxe change entre versions. Préciser la version utilisée dans le prompt.

**Contexte métier** : L'IA ne connaît pas vos conventions internes. Adapter les suggestions.

### Risques opérationnels

**Drift non détecté** : Des modifications manuelles dans AWS ne sont pas dans le state. Utiliser `terraform refresh`.

**Locks concurrents** : Plusieurs apply simultanés peuvent corrompre le state. Utiliser DynamoDB locking.

## Bonnes pratiques

### Avant validation IA

1. Avoir un state Terraform à jour (`terraform refresh`)
2. Sauvegarder le state actuel
3. Préparer un environnement de test pour appliquer corrections
4. Lister les outputs nécessaires aux autres modules

### Pendant l'analyse

1. Fournir le code complet (pas tronqué)
2. Préciser version Terraform et providers
3. Indiquer le contexte (prod, dev, compliance requise)
4. Demander explications pour chaque suggestion

### Après validation

1. Relire toutes les corrections proposées
2. Tester dans environnement non-prod
3. Valider que `terraform plan` ne montre pas de destruction inattendue
4. Appliquer les changements par batch (sécurité → optimisations)
5. Mettre à jour la documentation (README, CHANGELOG)

### CI/CD Terraform

1. Automatiser validation dans pipeline (fmt, validate, tfsec)
2. Bloquer merge si problèmes critiques
3. Générer plan automatiquement sur PR
4. Nécessiter approbation manuelle avant apply en prod

## Ce que cela démontre à un recruteur

### Compétences techniques

- Expertise Terraform et Infrastructure as Code
- Maîtrise AWS et sécurité cloud (CIS benchmark)
- Connaissance approfondie des best practices IaC
- Capacité d'audit et de refactoring de code complexe

### Efficacité

- Réduction du temps d'audit de 85-90%
- Détection automatique de failles de sécurité
- Correction rapide de code legacy
- Documentation générée automatiquement

### Utilisation stratégique de l'IA

- Analyse de cohérence inter-modules
- Génération de code sécurisé et optimisé
- Tests automatisés (Terratest)
- Accélération massive des revues de code

**Message au recruteur** : Ce guide démontre un ingénieur DevOps capable d'auditer rapidement du code Terraform complexe en exploitant l'IA pour détecter failles de sécurité, non-conformités et optimisations. La méthode garantit un code conforme aux standards AWS, sécurisé et performant, réduisant drastiquement les risques en production.
