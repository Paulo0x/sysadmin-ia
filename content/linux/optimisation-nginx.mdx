# Optimisation Nginx avec assistance IA

## Objectif

Optimiser les performances et la sécurité d'un serveur web Nginx en exploitant l'IA pour analyser la configuration actuelle, identifier les goulots d'étranglement et proposer des améliorations concrètes.

## Contexte entreprise

Une startup SaaS héberge son application web sur 3 serveurs Nginx (load balancing). Problèmes rencontrés :
- Temps de réponse lents (> 500ms) aux heures de pointe
- Pics de charge CPU lors des déploiements
- Configuration Nginx par défaut jamais optimisée
- Logs d'erreurs montrant des timeouts
- Score Google PageSpeed < 70/100

**Infrastructure** :
- 3 serveurs Ubuntu 22.04 (4 vCPU, 8 GB RAM chacun)
- Nginx 1.24
- Application backend Node.js (reverse proxy)
- Trafic : 50 000 requêtes/jour (pics à 200 req/sec)

**Objectif** : Réduire les temps de réponse de 50% et améliorer le score PageSpeed.

## Problème

Optimiser Nginx manuellement implique :
- Analyser les logs d'accès et d'erreurs
- Tester différentes configurations (workers, buffers, timeouts)
- Consulter la documentation Nginx volumineuse
- Comprendre les modules disponibles (cache, compression)
- Benchmarker chaque modification
- Risque de casser le site avec une mauvaise config

**Temps estimé** : 1-2 jours d'analyse + tests + ajustements

**Difficultés** :
- Multitude de paramètres à ajuster
- Impact immédiat sur la production si erreur
- Benchmarking chronophage

## Solution traditionnelle

### Méthode manuelle

1. Lire la configuration actuelle (`/etc/nginx/nginx.conf`)
2. Consulter les guides d'optimisation Nginx
3. Tester des modifications une par une
4. Benchmarker avec `ab` ou `wrk`
5. Ajuster progressivement
6. Documenter les changements

### Outils classiques

- `nginx -t` : Tester la configuration
- Apache Bench (`ab`) : Benchmarking
- `htop` : Monitoring CPU/RAM
- Logs access.log et error.log

### Limites

- Processus d'essai-erreur long
- Difficile d'identifier le paramètre optimal
- Risque de régression de performance

## Apport de l'IA

L'IA permet de :
- Analyser la configuration actuelle et identifier les faiblesses
- Proposer une configuration optimisée basée sur les best practices
- Expliquer chaque paramètre et son impact
- Générer des scripts de test automatisés
- Recommander des modules additionnels (cache, compression)

**Temps avec IA** : 2-4 heures (analyse + configuration + tests)

**Gain de productivité** : 70-80%

## Mise en œuvre étape par étape

### Étape 1 : Collecter les informations actuelles

#### Configuration actuelle

```bash
# Afficher la configuration principale
cat /etc/nginx/nginx.conf

# Afficher les configs de sites
cat /etc/nginx/sites-available/default

# Vérifier les modules chargés
nginx -V
```

**Configuration de base (exemple)** :

```nginx
user www-data;
worker_processes auto;
pid /run/nginx.pid;

events {
    worker_connections 768;
}

http {
    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    gzip on;

    include /etc/nginx/sites-enabled/*;
}
```

#### Métriques actuelles

```bash
# Benchmark actuel
ab -n 1000 -c 100 https://monsite.com/

# Résultats avant optimisation :
# Requests per second: 85.23 [#/sec]
# Time per request: 1173 [ms] (moyenne)
```

### Étape 2 : Analyser avec l'IA

**Prompt** :

```
Analyse cette configuration Nginx et propose des optimisations.

**Contexte :**
- Serveur Ubuntu 22.04, 4 vCPU, 8 GB RAM
- Nginx 1.24
- Backend : Node.js via reverse proxy (port 3000)
- Trafic : 50 000 req/jour, pics à 200 req/sec
- Application : API REST + SPA React

**Configuration actuelle :**
```nginx
[copier-coller nginx.conf]
```

**Problèmes observés :**
- Temps de réponse > 500ms aux heures de pointe
- CPU charge à 80% lors des pics
- Score Google PageSpeed : 68/100

**Questions :**
1. Quels paramètres optimiser en priorité ?
2. Quelle configuration recommandes-tu ?
3. Quels modules activer (cache, compression, etc.) ?
4. Comment configurer le reverse proxy pour Node.js ?
```

### Étape 3 : Configuration optimisée générée

**Réponse de l'IA (synthèse)** :

```
## Analyse de la configuration actuelle

### Points faibles identifiés

1. **worker_connections trop faible (768)**
   - Avec 4 vCPU, le serveur peut gérer bien plus de connexions simultanées
   - Recommandé : 4096 ou plus

2. **Pas de cache configuré**
   - Les ressources statiques ne sont pas cachées
   - Chaque requête recharge tout depuis Node.js

3. **Compression GZIP basique**
   - Pas de configuration des types de fichiers
   - Niveau de compression non défini

4. **Buffers par défaut**
   - Peuvent causer des timeouts pour gros payloads
   - Nécessitent ajustement pour API REST

5. **Timeouts non configurés**
   - Peuvent causer des connexions longues bloquantes

6. **Pas de rate limiting**
   - Vulnérable aux attaques DDoS/abus

### Configuration optimisée recommandée

```nginx
# /etc/nginx/nginx.conf

user www-data;
worker_processes auto;  # Détecte automatiquement le nombre de CPU
worker_rlimit_nofile 65535;  # Augmente la limite de fichiers ouverts
pid /run/nginx.pid;

events {
    worker_connections 4096;  # Augmenté de 768 à 4096
    use epoll;  # Méthode efficace sur Linux
    multi_accept on;  # Accepte plusieurs connexions à la fois
}

http {
    # ====================
    # PERFORMANCE
    # ====================

    # Sendfile optimisé
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;

    # Timeouts optimisés
    client_body_timeout 12;
    client_header_timeout 12;
    keepalive_timeout 65;
    send_timeout 10;

    # Buffers augmentés pour API REST
    client_body_buffer_size 128k;
    client_max_body_size 10m;
    client_header_buffer_size 1k;
    large_client_header_buffers 4 8k;

    # Types MIME
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # ====================
    # LOGS
    # ====================

    # Format de log optimisé
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct="$upstream_connect_time" '
                    'uht="$upstream_header_time" urt="$upstream_response_time"';

    access_log /var/log/nginx/access.log main buffer=32k;
    error_log /var/log/nginx/error.log warn;

    # ====================
    # COMPRESSION GZIP
    # ====================

    gzip on;
    gzip_vary on;
    gzip_min_length 256;  # Ne compresse que les fichiers > 256 bytes
    gzip_comp_level 6;  # Niveau 6 = bon compromis CPU/compression
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/rss+xml
        application/atom+xml
        image/svg+xml
        text/x-component
        application/x-font-ttf
        font/opentype;

    gzip_proxied any;
    gzip_disable "msie6";

    # ====================
    # CACHE STATIQUE
    # ====================

    # Cache des fichiers statiques
    open_file_cache max=2000 inactive=20s;
    open_file_cache_valid 60s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    # ====================
    # SÉCURITÉ
    # ====================

    # Cacher version Nginx
    server_tokens off;

    # Rate limiting (10 req/sec par IP)
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

    # Limite connexions (20 connexions simultanées par IP)
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;

    # ====================
    # INCLUDES
    # ====================

    include /etc/nginx/sites-enabled/*;
}
```

### Configuration du site (reverse proxy vers Node.js)

```nginx
# /etc/nginx/sites-available/default

# Cache proxy
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=app_cache:10m max_size=1g inactive=60m use_temp_path=off;

# Upstream Node.js
upstream nodejs_backend {
    least_conn;  # Load balancing par connexions
    server 127.0.0.1:3000 max_fails=3 fail_timeout=30s;
    keepalive 32;  # Keep-alive vers backend
}

server {
    listen 80;
    listen [::]:80;
    server_name monsite.com www.monsite.com;

    # Redirection HTTPS (si applicable)
    # return 301 https://$server_name$request_uri;

    # ====================
    # LOGS
    # ====================

    access_log /var/log/nginx/monsite_access.log main;
    error_log /var/log/nginx/monsite_error.log warn;

    # ====================
    # SÉCURITÉ
    # ====================

    # Headers de sécurité
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Rate limiting sur API
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        limit_conn conn_limit 20;

        proxy_pass http://nodejs_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # ====================
    # RESSOURCES STATIQUES
    # ====================

    # React SPA (build statique)
    location / {
        root /var/www/monsite/build;
        try_files $uri $uri/ /index.html;

        # Cache navigateur pour ressources statiques
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            access_log off;
        }

        # Pas de cache pour HTML
        location ~* \.html$ {
            expires -1;
            add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        }
    }

    # ====================
    # HEALTHCHECK
    # ====================

    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
```

### Explications des paramètres clés

| Paramètre | Valeur | Impact |
|-----------|--------|--------|
| worker_connections | 4096 | Permet 4096 connexions simultanées par worker |
| gzip_comp_level | 6 | Réduit la taille des réponses de ~70% |
| proxy_cache_path | 1g | Cache 1 GB de réponses backend |
| keepalive 32 | 32 connexions | Réutilise les connexions vers Node.js |
| limit_req | 10r/s | Protège contre DDoS (10 req/sec par IP) |
| expires 1y | JS/CSS | Cache navigateur pendant 1 an |

### Tests de performance attendus

Après cette optimisation :
- **Requests per second** : 85 → 300+ (x3.5)
- **Time per request** : 1173ms → 350ms (-70%)
- **Score PageSpeed** : 68 → 90+ (+22 points)
- **Utilisation CPU** : 80% → 45% (-35%)
```

### Étape 4 : Appliquer la configuration

#### Backup de la config actuelle

```bash
sudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup.$(date +%Y%m%d)
sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.backup.$(date +%Y%m%d)
```

#### Appliquer la nouvelle config

```bash
# Éditer nginx.conf
sudo nano /etc/nginx/nginx.conf
# Coller la config optimisée

# Éditer le site
sudo nano /etc/nginx/sites-available/default
# Coller la config du site

# Créer le dossier de cache
sudo mkdir -p /var/cache/nginx
sudo chown www-data:www-data /var/cache/nginx

# Tester la syntaxe
sudo nginx -t

# Si OK, recharger Nginx
sudo systemctl reload nginx
```

### Étape 5 : Benchmarking et validation

```bash
# Benchmark après optimisation
ab -n 1000 -c 100 https://monsite.com/

# Monitoring en temps réel
watch -n 1 'curl -s http://localhost/nginx_status'

# Vérifier les logs d'erreurs
sudo tail -f /var/log/nginx/error.log
```

**Résultats attendus** :
- Requests per second : 300+ (vs 85 avant)
- Time per request : 350ms (vs 1173ms avant)
- CPU usage : 45% (vs 80% avant)

## Scripts / Commandes / Configurations

### Script de test automatisé

```bash
#!/bin/bash
# benchmark-nginx.sh
# Compare les performances avant/après optimisation

echo "=== Benchmark Nginx ==="

URL="https://monsite.com"
REQUESTS=1000
CONCURRENCY=100

echo "URL: $URL"
echo "Requests: $REQUESTS"
echo "Concurrency: $CONCURRENCY"
echo ""

# Warmup
echo "[Warmup] 100 requêtes..."
ab -n 100 -c 10 $URL > /dev/null 2>&1

# Benchmark
echo "[Benchmark] En cours..."
ab -n $REQUESTS -c $CONCURRENCY $URL > /tmp/benchmark.txt

# Extraction des résultats
RPS=$(grep "Requests per second" /tmp/benchmark.txt | awk '{print $4}')
TIME=$(grep "Time per request" /tmp/benchmark.txt | grep "mean" | awk '{print $4}')
FAILED=$(grep "Failed requests" /tmp/benchmark.txt | awk '{print $3}')

echo ""
echo "=== Résultats ==="
echo "Requests per second: $RPS"
echo "Time per request: ${TIME}ms"
echo "Failed requests: $FAILED"

# Score
if (( $(echo "$RPS > 200" | bc -l) )); then
    echo "✓ Performance excellente (> 200 req/sec)"
elif (( $(echo "$RPS > 100" | bc -l) )); then
    echo "⚠ Performance acceptable (100-200 req/sec)"
else
    echo "✗ Performance insuffisante (< 100 req/sec)"
fi
```

### Monitoring avec stub_status

```nginx
# Ajouter dans nginx.conf (bloc server)
location /nginx_status {
    stub_status on;
    access_log off;
    allow 127.0.0.1;
    deny all;
}
```

Accès :
```bash
curl http://localhost/nginx_status
```

### Script de rollback rapide

```bash
#!/bin/bash
# rollback-nginx.sh

BACKUP_DATE=$(ls -t /etc/nginx/nginx.conf.backup.* | head -1 | grep -oP '\d{8}$')

echo "Rollback vers backup du $BACKUP_DATE"

sudo cp /etc/nginx/nginx.conf.backup.$BACKUP_DATE /etc/nginx/nginx.conf
sudo cp /etc/nginx/sites-available/default.backup.$BACKUP_DATE /etc/nginx/sites-available/default

sudo nginx -t && sudo systemctl reload nginx

echo "✓ Rollback effectué"
```

## Risques et limites

### Risques de configuration

**Nginx ne démarre plus** : Une erreur de syntaxe peut empêcher Nginx de démarrer. Toujours tester avec `nginx -t` avant reload.

**Augmentation de la RAM** : Le cache Nginx consomme de la RAM. Monitorer avec `free -h`.

### Limites de l'IA

**Contexte applicatif** : L'IA propose des optimisations génériques. Votre application peut avoir des besoins spécifiques (websockets, upload de gros fichiers).

**Trade-offs** : Certaines optimisations augmentent l'usage RAM/disque. L'IA ne connaît pas vos ressources disponibles.

### Risques opérationnels

**Impact utilisateurs** : Un reload Nginx peut causer une brève interruption (&lt;1s). Planifier en dehors des heures de pointe.

**Cache agressif** : Un cache mal configuré peut servir des données obsolètes.

## Bonnes pratiques

### Avant optimisation

1. Benchmarker les performances actuelles (baseline)
2. Sauvegarder la configuration actuelle
3. Tester en environnement de staging d'abord
4. Prévoir un plan de rollback

### Pendant l'optimisation

1. Appliquer les modifications une par une si possible
2. Tester la syntaxe avec `nginx -t` après chaque modification
3. Monitorer les logs en temps réel
4. Valider avec des benchmarks

### Après optimisation

1. Benchmarker les nouvelles performances
2. Monitorer pendant 24-48h (CPU, RAM, logs)
3. Ajuster si nécessaire
4. Documenter les changements et les résultats

### Maintenance

1. Réviser la config tous les 6 mois
2. Mettre à jour Nginx régulièrement
3. Monitorer les logs pour détecter des anomalies
4. Ajuster selon l'évolution du trafic

## Ce que cela démontre à un recruteur

### Compétences techniques

- Maîtrise de Nginx (configuration, optimisation)
- Compréhension de la performance web
- Benchmarking et analyse de métriques

### Approche méthodique

- Analyse avant action (collecte métriques)
- Tests et validation systématiques
- Documentation des changements

### Utilisation stratégique de l'IA

- Accélération de l'analyse de configuration
- Recommandations basées sur best practices
- Gain de temps de 70-80%

### Résultats mesurables

- Temps de réponse réduit de 70%
- Capacité multipliée par 3.5
- Score PageSpeed +22 points
- Utilisation CPU réduite de 35%

**Message au recruteur** : Ce guide démontre un ingénieur capable d'optimiser significativement les performances d'un serveur web Nginx en exploitant l'IA pour accélérer l'analyse et les recommandations. Les résultats sont mesurables (x3.5 capacité, -70% temps réponse) et la méthode est rigoureuse (backup, tests, validation), garantissant des optimisations sans risque pour la production.
