# Automatisation Bash avec assistance IA

## Objectif

Créer des scripts Bash robustes pour automatiser des tâches système courantes (backups, monitoring, maintenance) en exploitant l'IA pour générer du code de qualité professionnelle avec gestion d'erreurs et logging.

## Contexte entreprise

Un administrateur Linux gère 10 serveurs Ubuntu/Debian et passe 2-3 heures/jour sur des tâches répétitives :
- Vérification espace disque
- Nettoyage logs anciens
- Surveillance services critiques
- Backups manuels
- Génération rapports

**Objectif** : Automatiser 80% de ces tâches via scripts Bash.

## Problème

Créer des scripts Bash robustes implique :
- Connaissance approfondie de la syntaxe Bash
- Gestion d'erreurs (exit codes, try/catch)
- Logging structuré
- Parsing d'arguments
- Tests de chaque cas limite

**Temps estimé** : 1-3 heures par script selon complexité

**Difficultés** :
- Syntaxe Bash parfois cryptique
- Gestion d'erreurs verbieuse
- Risque de scripts fragiles

## Solution traditionnelle

### Méthode manuelle

```bash
# Script basique sans robustesse
#!/bin/bash
du -sh /var/log
rm -rf /var/log/*.log.1
```

**Problèmes** :
- Pas de gestion d'erreurs
- Pas de logging
- Pas de vérification avant suppression

## Apport de l'IA

L'IA permet de :
- Générer des scripts complets avec gestion d'erreurs
- Inclure automatiquement du logging
- Ajouter des validations de sécurité
- Documenter le code avec commentaires clairs
- Proposer des améliorations de performance

**Temps avec IA** : 15-30 minutes par script (génération + tests)

**Gain de productivité** : 70-80%

## Exemples de scripts générés

### Script 1 : Monitoring espace disque

**Prompt** :

```
Génère un script Bash pour monitorer l'espace disque.

Le script doit :
1. Vérifier l'espace disque sur tous les points de montage
2. Alerter si usage > 80%
3. Envoyer un email si critique (> 90%)
4. Logger dans /var/log/disk-monitor.log
5. Exécutable quotidiennement via cron

Inclure :
- Gestion d'erreurs
- Logging avec timestamps
- Paramètres configurables (seuils d'alerte)

Format : Script Bash complet, commenté
```

**Script généré** :

```bash
#!/bin/bash
#
# disk-monitor.sh
# Surveillance espace disque avec alertes
# Usage: ./disk-monitor.sh

set -euo pipefail

# Configuration
WARN_THRESHOLD=80
CRIT_THRESHOLD=90
LOG_FILE="/var/log/disk-monitor.log"
EMAIL_TO="admin@entreprise.com"
EMAIL_FROM="monitoring@server"

# Couleurs pour output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Fonction logging
log() {
    local level=$1
    shift
    local message="$@"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp][$level] $message" | tee -a "$LOG_FILE"
}

# Fonction d'envoi email
send_alert_email() {
    local subject=$1
    local body=$2

    if command -v mail &> /dev/null; then
        echo "$body" | mail -s "$subject" -r "$EMAIL_FROM" "$EMAIL_TO"
        log "INFO" "Email envoyé à $EMAIL_TO"
    else
        log "ERROR" "Commande 'mail' non disponible, email non envoyé"
    fi
}

# Fonction principale de vérification
check_disk_space() {
    log "INFO" "=== Début vérification espace disque ==="

    local has_warning=false
    local has_critical=false
    local alert_message=""

    # Récupérer tous les systèmes de fichiers (sauf tmpfs, devtmpfs)
    df -H --output=source,pcent,avail,target | tail -n +2 | grep -v "tmpfs\|devtmpfs" | while read filesystem usage avail mount; do
        # Extraire le pourcentage sans le %
        usage_num=${usage%%%}

        log "INFO" "Vérification $mount : $usage utilisé ($avail disponible)"

        if [ "$usage_num" -ge "$CRIT_THRESHOLD" ]; then
            echo -e "${RED}[CRITIQUE]${NC} $mount : $usage utilisé"
            log "CRITICAL" "$mount : $usage utilisé (seuil critique : $CRIT_THRESHOLD%)"
            alert_message+="CRITIQUE: $mount à $usage\n"
            has_critical=true

        elif [ "$usage_num" -ge "$WARN_THRESHOLD" ]; then
            echo -e "${YELLOW}[WARNING]${NC} $mount : $usage utilisé"
            log "WARNING" "$mount : $usage utilisé (seuil warning : $WARN_THRESHOLD%)"
            alert_message+="WARNING: $mount à $usage\n"
            has_warning=true

        else
            echo -e "${GREEN}[OK]${NC} $mount : $usage utilisé"
        fi
    done

    # Envoyer email si critique
    if [ "$has_critical" = true ]; then
        send_alert_email "URGENT : Espace disque critique sur $(hostname)" "$alert_message"
    elif [ "$has_warning" = true ]; then
        log "WARNING" "Certains disques dépassent le seuil d'alerte"
    fi

    log "INFO" "=== Fin vérification ==="
}

# Point d'entrée
main() {
    # Vérifier que le script est exécuté en root (pour logs)
    if [ ! -w "$(dirname "$LOG_FILE")" ]; then
        echo "Erreur : Impossible d'écrire dans $LOG_FILE"
        echo "Exécuter en root ou modifier la variable LOG_FILE"
        exit 1
    fi

    check_disk_space
}

# Exécution
main "$@"
```

### Script 2 : Nettoyage automatique logs

**Prompt** :

```
Génère un script Bash pour nettoyer les logs anciens.

Le script doit :
1. Supprimer les fichiers .log > 30 jours dans /var/log
2. Compresser les fichiers .log entre 7 et 30 jours
3. Vérifier l'espace libéré
4. Logging complet
5. Mode dry-run (simulation sans suppression)

Sécurité :
- Exclure certains fichiers critiques (auth.log, syslog actuel)
- Confirmation avant suppression si exécuté manuellement
- Rapport des actions effectuées

Format : Script Bash complet
```

**Script généré** :

```bash
#!/bin/bash
#
# cleanup-logs.sh
# Nettoyage et compression des logs anciens
# Usage: ./cleanup-logs.sh [--dry-run]

set -euo pipefail

# Configuration
LOG_DIR="/var/log"
COMPRESS_DAYS=7
DELETE_DAYS=30
EXCLUDE_PATTERNS=("auth.log" "syslog" "kern.log")
LOG_FILE="/var/log/cleanup-logs.log"
DRY_RUN=false

# Parse arguments
if [[ "${1:-}" == "--dry-run" ]]; then
    DRY_RUN=true
    echo "[MODE DRY-RUN] Aucune modification ne sera effectuée"
fi

# Logging
log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $*" | tee -a "$LOG_FILE"
}

# Vérifier si fichier doit être exclu
is_excluded() {
    local file=$1
    for pattern in "${EXCLUDE_PATTERNS[@]}"; do
        if [[ "$file" == *"$pattern"* ]]; then
            return 0
        fi
    done
    return 1
}

# Compresser fichiers anciens
compress_old_logs() {
    log "Recherche fichiers à compresser (> $COMPRESS_DAYS jours, < $DELETE_DAYS jours)..."

    local compressed_count=0
    local compressed_size=0

    find "$LOG_DIR" -type f -name "*.log" -mtime +$COMPRESS_DAYS -mtime -$DELETE_DAYS | while read file; do
        if is_excluded "$file"; then
            log "SKIP: $file (exclu)"
            continue
        fi

        if [[ "$file" == *.gz ]]; then
            log "SKIP: $file (déjà compressé)"
            continue
        fi

        local size_before=$(stat -c%s "$file")

        if [ "$DRY_RUN" = false ]; then
            gzip "$file" && log "Compressé: $file" || log "ERREUR compression: $file"
        else
            log "[DRY-RUN] Compresser: $file"
        fi

        compressed_count=$((compressed_count + 1))
        compressed_size=$((compressed_size + size_before))
    done

    log "Total compressés: $compressed_count fichiers (~$((compressed_size / 1024 / 1024)) MB)"
}

# Supprimer fichiers très anciens
delete_old_logs() {
    log "Recherche fichiers à supprimer (> $DELETE_DAYS jours)..."

    local deleted_count=0
    local deleted_size=0

    find "$LOG_DIR" -type f \( -name "*.log" -o -name "*.log.gz" \) -mtime +$DELETE_DAYS | while read file; do
        if is_excluded "$file"; then
            log "SKIP: $file (exclu)"
            continue
        fi

        local size=$(stat -c%s "$file")

        if [ "$DRY_RUN" = false ]; then
            rm -f "$file" && log "Supprimé: $file" || log "ERREUR suppression: $file"
        else
            log "[DRY-RUN] Supprimer: $file"
        fi

        deleted_count=$((deleted_count + 1))
        deleted_size=$((deleted_size + size))
    done

    log "Total supprimés: $deleted_count fichiers (~$((deleted_size / 1024 / 1024)) MB libérés)"
}

# Rapport final
generate_report() {
    log "=== Rapport de nettoyage ==="
    log "Espace disque avant : $(df -h "$LOG_DIR" | tail -1 | awk '{print $3 " utilisé sur " $2}')"

    compress_old_logs
    delete_old_logs

    log "Espace disque après : $(df -h "$LOG_DIR" | tail -1 | awk '{print $3 " utilisé sur " $2}')"
    log "=== Fin ==="
}

# Point d'entrée
main() {
    if [ "$EUID" -ne 0 ]; then
        echo "Ce script doit être exécuté en root"
        exit 1
    fi

    log "=== Début nettoyage logs ==="
    generate_report
}

main "$@"
```

### Script 3 : Surveillance services critiques

**Prompt** :

```
Génère un script Bash pour surveiller des services Linux.

Le script doit :
1. Vérifier l'état de services critiques (nginx, postgresql, docker)
2. Tenter redémarrage automatique si service down
3. Envoyer alerte si redémarrage échoue
4. Logger toutes les actions
5. Rapport quotidien (synthèse)

Inclure :
- Vérification avec systemctl
- Retry mechanism (3 tentatives)
- Délai entre tentatives
- Email d'alerte

Format : Script Bash complet
```

**Script généré** :

```bash
#!/bin/bash
#
# service-monitor.sh
# Surveillance et redémarrage automatique services critiques
# Usage: ./service-monitor.sh

set -euo pipefail

# Configuration
SERVICES=("nginx" "postgresql" "docker")
MAX_RETRIES=3
RETRY_DELAY=10
LOG_FILE="/var/log/service-monitor.log"
EMAIL_TO="admin@entreprise.com"

# Logging
log() {
    local level=$1
    shift
    local message="$@"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp][$level] $message" | tee -a "$LOG_FILE"
}

# Vérifier et redémarrer un service
check_and_restart_service() {
    local service=$1

    log "INFO" "Vérification service: $service"

    if systemctl is-active --quiet "$service"; then
        log "INFO" "$service: OK (actif)"
        return 0
    else
        log "WARNING" "$service: DOWN (inactif)"

        # Tentatives de redémarrage
        for i in $(seq 1 $MAX_RETRIES); do
            log "INFO" "$service: Tentative redémarrage $i/$MAX_RETRIES"

            if systemctl restart "$service"; then
                sleep 2
                if systemctl is-active --quiet "$service"; then
                    log "SUCCESS" "$service: Redémarré avec succès"
                    return 0
                fi
            fi

            log "WARNING" "$service: Échec tentative $i"
            sleep $RETRY_DELAY
        done

        # Toutes les tentatives ont échoué
        log "CRITICAL" "$service: Redémarrage échoué après $MAX_RETRIES tentatives"

        # Envoyer email d'alerte
        local subject="ALERTE: Service $service DOWN sur $(hostname)"
        local body="Le service $service est arrêté et ne peut pas être redémarré.\n\nLogs:\n$(systemctl status $service --no-pager)"

        echo -e "$body" | mail -s "$subject" "$EMAIL_TO"

        return 1
    fi
}

# Surveillance de tous les services
monitor_all_services() {
    log "INFO" "=== Début surveillance services ==="

    local failed_services=()

    for service in "${SERVICES[@]}"; do
        if ! check_and_restart_service "$service"; then
            failed_services+=("$service")
        fi
        echo ""
    done

    # Résumé
    if [ ${#failed_services[@]} -eq 0 ]; then
        log "INFO" "Tous les services sont opérationnels"
    else
        log "CRITICAL" "Services en échec: ${failed_services[*]}"
    fi

    log "INFO" "=== Fin surveillance ==="
}

# Point d'entrée
main() {
    if [ "$EUID" -ne 0 ]; then
        echo "Ce script doit être exécuté en root"
        exit 1
    fi

    monitor_all_services
}

main "$@"
```

## Automatisation avec Cron

```bash
# Éditer crontab
sudo crontab -e

# Monitoring disque : quotidien à 8h
0 8 * * * /root/scripts/disk-monitor.sh >> /var/log/cron-disk.log 2>&1

# Nettoyage logs : hebdomadaire (dimanche 2h)
0 2 * * 0 /root/scripts/cleanup-logs.sh >> /var/log/cron-cleanup.log 2>&1

# Surveillance services : toutes les 10 minutes
*/10 * * * * /root/scripts/service-monitor.sh >> /var/log/cron-services.log 2>&1
```

## Bonnes pratiques

### Avant génération

1. Définir précisément le besoin (entrées, sorties, cas limites)
2. Identifier les erreurs possibles
3. Déterminer les actions en cas d'erreur

### Pendant la génération

1. Demander explicitement gestion d'erreurs et logging
2. Inclure des exemples d'utilisation
3. Spécifier les permissions requises

### Après génération

1. Relire entièrement le code généré
2. Tester en environnement de dev
3. Valider tous les cas limites
4. Documenter le script

### Sécurité

1. Ne jamais hardcoder de credentials
2. Valider toutes les entrées utilisateur
3. Utiliser `set -euo pipefail` pour exit on error
4. Limiter les permissions (chmod 700)

## Ce que cela démontre à un recruteur

### Compétences techniques

- Maîtrise Bash et scripting Linux
- Automatisation de tâches système
- Gestion d'erreurs et logging professionnels

### Efficacité

- Réduction du temps de développement de 70-80%
- Scripts robustes dès la première itération
- Automatisation = gain de 2-3h/jour

### Utilisation stratégique de l'IA

- Génération de code de qualité production
- Inclusion automatique de best practices
- Gain de temps sans compromis qualité

**Message au recruteur** : Ce guide démontre un administrateur système capable d'automatiser efficacement des tâches répétitives via des scripts Bash robustes. L'utilisation de l'IA accélère le développement (gain 70-80%) tout en garantissant la qualité (gestion d'erreurs, logging, sécurité), libérant du temps pour des tâches à plus forte valeur ajoutée.
